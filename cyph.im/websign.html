<!DOCTYPE html>
<html manifest='/websign/cyph.appcache'>
	<head>
		<meta charset='utf-8' />
		<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1' />
		<meta name='google' content='notranslate' />
		<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no' />
		<meta name='apple-mobile-web-app-capable' content='yes' />
		<meta name='mobile-web-app-capable' content='yes' />

		<title>Cyph &ndash; Encrypted Messenger</title>

		<link rel='apple-touch-icon' sizes='57x57' href='/img/favicon/apple-touch-icon-57x57.png' />
		<link rel='apple-touch-icon' sizes='114x114' href='/img/favicon/apple-touch-icon-114x114.png' />
		<link rel='apple-touch-icon' sizes='72x72' href='/img/favicon/apple-touch-icon-72x72.png' />
		<link rel='apple-touch-icon' sizes='144x144' href='/img/favicon/apple-touch-icon-144x144.png' />
		<link rel='apple-touch-icon' sizes='60x60' href='/img/favicon/apple-touch-icon-60x60.png' />
		<link rel='apple-touch-icon' sizes='120x120' href='/img/favicon/apple-touch-icon-120x120.png' />
		<link rel='apple-touch-icon' sizes='76x76' href='/img/favicon/apple-touch-icon-76x76.png' />
		<link rel='apple-touch-icon' sizes='152x152' href='/img/favicon/apple-touch-icon-152x152.png' />
		<link rel='apple-touch-icon' sizes='180x180' href='/img/favicon/apple-touch-icon-180x180.png' />
		<link rel='icon' type='image/png' href='/img/favicon/favicon-192x192.png' sizes='192x192' />
		<link rel='icon' type='image/png' href='/img/favicon/favicon-160x160.png' sizes='160x160' />
		<link rel='icon' type='image/png' href='/img/favicon/favicon-96x96.png' sizes='96x96' />
		<link rel='icon' type='image/png' href='/img/favicon/favicon-16x16.png' sizes='16x16' />
		<link rel='icon' type='image/png' href='/img/favicon/favicon-32x32.png' sizes='32x32' />
		<meta name='msapplication-TileColor' content='#8b62d9' />
		<meta name='msapplication-TileImage' content='/img/favicon/mstile-144x144.png' />

		<link rel='stylesheet' href='/websign/css/loading.css' />
	</head>
	<body>
		<div id='pre-load'>
			<div class='double-bounce1'></div>
			<div class='double-bounce2'></div>
			<div class='message'>
				<p>
					Validating cryptographic signature...
				</p>
				<p>
					Please wait; this may take a few seconds.
				</p>
			</div>
		</div>

		<script src='/websign/js/cryptoInit.js'></script>
		<script src='/websign/js/webSignPublicKeys.js'></script>

		<script src='/websign/lib/sha512.js'></script>
		<script src='/websign/lib/openpgp/openpgp.min.js'></script>
		<script> openpgp.initWorker('/websign/lib/openpgp/openpgp.worker.min.js') </script>

		<script>(function () {


		window.WebSign	= {
			bootstrapText: '',

			cdnUrl: '',

			continent: '',

			isOnion: document.location.host.split('.').slice(-1)[0] === 'onion',

			config: {
				abortUrl: 'https://www.cyph.com',
				cdnUrlBase: '.cdn.cyph.com/websign/',
				continentUrl: 'https://api.cyph.com/continent',
				defaultContinent: 'eu',
				hashPath: 'cyph.im.hash',
				packagePath: 'cyph.im.pkg',
				urlProtocol: 'https://',

				files: [
					'/',
					'/websign/css/loading.css',
					'/websign/js/cryptoInit.js',
					'/websign/js/webSignPublicKeys.js',
					'/websign/js/workerHelper.js',
					'/websign/lib/sha512.js',
					'/websign/lib/openpgp/openpgp.min.js',
					'/websign/lib/openpgp/openpgp.worker.min.js',
					'/websign/cyph.appcache'
				],

				publicKeys: PUBLIC_KEYS
			},

			detectChange: function () {
				if (!('webSignBootHash' in localStorage)) {
					return false;
				}

				localStorage.webSignBootHashOld	= localStorage.webSignBootHash;
				localStorage.webSignBootHash	= CryptoJS.SHA512(WebSign.bootstrapText).toString();

				return localStorage.webSignBootHashOld !== localStorage.webSignBootHash;
			},

			loadBootstrapText: function (callback, bootstrapText, i) {
				bootstrapText	= bootstrapText || '';
				i				= i || 0;

				var file	= WebSign.config.files[i];

				request({
					url: file,
					success: function (data) {
						bootstrapText	+= file + ':\n\n' + data + '\n\n\n\n\n\n';

						++i;

						if (i >= WebSign.config.files.length) {
							WebSign.bootstrapText	= bootstrapText;
							callback();
						}
						else {
							WebSign.loadBootstrapText(callback, bootstrapText, i);
						}
					}
				});
			},

			shouldRetry: function () {
				return !(
					WebSign.isOnion ||
					WebSign.continent === WebSign.config.defaultContinent
				);
			},

			toString: function (shouldIncludeBootstrapText) {
				return (
					'\n\ncontinent: ' + WebSign.continent +
					'\n\ncurrent bootstrap hash: ' + localStorage.webSignBootHash +
					'\n\nprevious bootstrap hash: ' + localStorage.webSignBootHashOld +
					'\n\npackage hash: ' + localStorage.webSignHash +
					(
						shouldIncludeBootstrapText ?
							('\n\n\n\n' + WebSign.bootstrapText) :
							''
					)
				);
			}
		};


		if (WebSign.isOnion) {
			WebSign.config.abortUrl			= '/404';
			WebSign.config.cdnUrlBase		= '/cdn/websign/';
			WebSign.config.continentUrl		= '';
			WebSign.config.defaultContinent	= '';
			WebSign.config.urlProtocol		= '';
		}



		/*** Main ***/

		WebSign.loadBootstrapText(function () {
			if (WebSign.isOnion) {
				main();
			}
			else {
				/* Get user's current location to choose optimal CDN node */
				request({
					url: WebSign.config.continentUrl,
					success: main
				});
			}
		});


		function main (continent) {
			setCdnContinent(continent);

			/* Get latest signed hash */
			var requestArgs	= {
				url: WebSign.cdnUrl + WebSign.config.hashPath,
				data: Date.now(),
				error: function () {
					if (WebSign.shouldRetry()) {
						setCdnContinent();
						request(requestArgs);
					}
					else {
						abort();
					}
				},
				success: function (signedHashText) {
					var previousHash			= localStorage.webSignHash;
					var previousHashTimestamp	= parseInt(localStorage.webSignHashTimestamp, 10);
					var previousHashExpires		= parseInt(localStorage.webSignHashExpires, 10);

					try {
						var signedHashes	= [];

						signedHashes.push(openpgp.cleartext.readArmored(signedHashText));
						signedHashes.push(openpgp.cleartext.readArmored(signedHashes[0].getText()));

						var o				= JSON.parse(signedHashes[1].getText());
						var hashText		= o.hash;
						var hashTimestamp	= o.timestamp;
						var hashExpires		= o.expires;

						/* If not expired and more recent than previous known good hash,
							validate signatures before accepting it */
						if (
							hashExpires > Date.now() &&
							(
								!previousHashTimestamp ||
								hashTimestamp > previousHashTimestamp
							)
						) {
							var validKeys	= {};

							signedHashes.forEach(function (signedHash) {
								for (var i = 0 ; i < WebSign.config.publicKeys.length ; ++i) {
									var publicKey	= WebSign.config.publicKeys[i];

									if (
										signedHash.verify(
											openpgp.key.readArmored(publicKey).keys
										)[0].valid
									) {
										validKeys[publicKey]	= true;
										return;
									}
								}
							});

							var isValid	= Object.keys(validKeys).length === signedHashes.length;


							if (isValid) {
								if (localStorage.webSignManualUpgrades) {
									if (confirm('Update to package with hash ' + hashText + '?')) {
										alert('Applying update.');
									}
									else {
										alert('Update rejected.');
										throw true;
									}
								}

								localStorage.webSignHash			= hashText;
								localStorage.webSignHashTimestamp	= hashTimestamp;
								localStorage.webSignHashExpires		= hashExpires;
							}
						}
					}
					catch (_) {}

					/* Get latest package and compare hashes before executing;
						if hashes differ, try falling back to last known good package,
						then if that fails retry everything with default fallback CDN node,
						then finally abort if that still fails */
					loadPackage(function () {
						if (previousHash && previousHashTimestamp && previousHashExpires) {
							localStorage.webSignHash			= previousHash;
							localStorage.webSignHashTimestamp	= previousHashTimestamp;
							localStorage.webSignHashExpires		= previousHashExpires;
						}

						loadPackage(WebSign.shouldRetry() ? main : abort);
					});
				}
			};

			request(requestArgs);
		}



		/*** Helpers ***/

		function abort () {
			document.location.href	= WebSign.config.abortUrl;
		}

		function getValue (o, k, defaultValue) {
			return k in o ? o[k] : defaultValue;
		}

		function request (o) {
			var data	= getValue(o, 'data', '');
			var error	= getValue(o, 'error', abort);
			var retries	= getValue(o, 'retries', 3);
			var success	= getValue(o, 'success', function() {});
			var url		= o.url;

			if (data) {
				url	+= '?' + data;
			}

			var xhr	= new XMLHttpRequest;

			xhr.onreadystatechange = function() {
				if (xhr.readyState === 4) {
					if (xhr.status === 200) {
						success(xhr.responseText);
					}
					else if (retries > 0) {
						o.retries	= retries - 1;
						xhr(o);
					}
					else {
						error(xhr.responseText);
					}
				}
			};

			xhr.open('GET', url, true);
			xhr.send();
		}


		function loadPackage (errorHandler) {
			errorHandler	= errorHandler || abort;

			var hashExists		= 'webSignHash' in localStorage;
			var hashExpireDate	= parseInt(localStorage.webSignHashExpires, 10);

			if (hashExists && hashExpireDate > Date.now()) {
				request({
					url: WebSign.cdnUrl + WebSign.config.packagePath,
					data: localStorage.webSignHash,
					error: errorHandler,
					success: function (payload) {
						if (CryptoJS.SHA512(payload).toString() === localStorage.webSignHash) {
							document.open('text/html');
							document.write(payload);
							document.close();
						}
						else {
							errorHandler();
						}
					}
				});
			}
			/* Hash is bad or outdated */
			else {
				errorHandler();
			}
		}

		function setCdnContinent (continent) {
			WebSign.continent	= continent || WebSign.config.defaultContinent;

			WebSign.cdnUrl		=
				WebSign.config.urlProtocol +
				WebSign.continent +
				WebSign.config.cdnUrlBase
			;
		}


		}());</script>
	</body>
</html>
